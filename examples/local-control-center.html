<html>

<head>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css" />
    <link rel="stylesheet" type="text/css" href="../dist/styles/talkify-common.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/colors.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/talkify-playlist.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/classic-control-center/colors.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/classic-control-center/main.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/modern-control-center/main.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/modern-control-center/colors.css">

    <link rel="stylesheet" type="text/css" href="../dist/styles/local-control-center/main.css">
    <link rel="stylesheet" type="text/css" href="../dist/styles/local-control-center/colors.css">
</head>

<body>
    <section id="root">
        <div class="talkify-control-center-placeholder"></div>
        <div class="talkify-section">
            <p>Hello, this is a local control center test. Yes, yes it is. It really is.
            </p>
            <p>
                Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the
                industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and
                scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap
                into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the
                release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing
                software like Aldus PageMaker including versions of Lorem Ipsum.
            </p>

            <p>
                Being able to access the camera within the browser without using third party software is an incredible
                advancement. Paired with canvas and a bit of JavaScript, the camera has become quickly and easily
                accessible. Not only it the camera accessible, but since canvas is ultra-flexible, we'll be able to add
                sexy Instagram-style image filters in the future. For now, however, simply accessing the camera in our
                browser moves us miles ahead. Have fun taking images within your browser!
            </p>


            <p>
                Each of these elements should be created once confirmation of camera support is confirmed, but for the
                sake of this tutorial, I wanted to show you what the elements look like with basic HTML. Do note that
                the dimensions we're working with are 640x480.

                The JavaScript
                Since the HTML elements above are already created, the JavaScript portion will look smaller than you
                think:
            </p>
            <p>
                Once it's been established that the browser supports navigator.mediaDevices.getUserMedia, a simple method sets the video element's src to the user's live camera/webcam.  Calling the play method of the video then starts the element's live streaming video connection.  That's all that's required to connect your camera to the browser!

Taking a photo is only marginally more difficult.  Simply add a click listener to a generic button and and draw an image from video!
            </p>
            <p>
                SCOTT HANSELMAN
about blog podcast youtube speaking
Learn to Tweet, Be a Better Developer, etc.
 browse by category or date
Classic Path.DirectorySeparatorChar gotchas when moving from .NET Core on Windows to Linux
October 13, 2020 Comment on this post [0] Posted in Azure | DotNetCore | Linux 
Sponsored By

Report Ad
It's a Unix System, I know this!An important step in moving my blog to Azure was to consider getting this .NET app, now a .NET Core app, to run on Linux AND Windows. Being able to run on Linux and Windows would give me and others a wider choice of hosting, allow hosting in Linux Containers, and for me, save me money as Linux Hosting tends to be cheaper, even on Azure.

Getting something to compile on Linux is not the same as getting it to run, of course.

Additionally, something might run well in one context and not other. My partner Mark (poppastring) on this project has been running this code on .NET for a while, albeit on Windows. Additionally he runs on IIS in /blog as a subapplication. I run on Linux on Azure, and while I'm also on /blog, my site is behind Azure Front Door as a reverse proxy which handles the domain/blog/path and forwards along domain/path to the app.

Long story short, it's worked on both his blog and mine, until I tried to post a new blog post.

I use Open Live Writer (open sourced version of Windows Live Writer) to make a MetaWebLog API call to my blog. There's multiple calls to upload the binaries (PNGs) and a path is returned.  A newly uploaded binary might have a path like https://hanselman.com/blog/content/binary/something.png. The file on disk (from the server's perspective) might be d:\whatever\site\wwwroot\content\binary\something.png.

This is 15 year old ASP.NET 1, so there's some idiomatic stuff going on here that isn't modern, plus the vars have been added for watch window debugging, but do you see the potential issue?

private string GetAbsoluteFileUri(string fullPath, out string relFileUri)
{
    var relPath = fullPath.Replace(contentLocation, "").TrimStart('\\'); 
    var relUri = new Uri( relPath, UriKind.Relative);
    relFileUri = relUri.ToString();
    return new Uri(binaryRoot, relPath).ToString();
}
That '\\' is making a big assumption. A reasonable one in 2003, but a big one today. It's trimming a backslash off the start of the passed in string. Then the Uri constructor starts coming things and we're mixing and matching \ and / and we end up with truncated URLs that don't resolve.

Assumptions about path separators are a top issue when moving .NET code to Linux or Mac, and it's often buried deep in utiltiy methods like this.

var relPath = fullPath.Replace(contentLocation, String.Empty).TrimStart(Path.DirectorySeparatorChar);
We can use the correct constant for Path.DirectorySeparatorChar, or the little-known AltDirectorySeparatorChar as Windows supports both. That's why this code works on Mark's Windows deployment but doesn't break until it runs on my Linux deployment.

DOCS: Note that Windows supports either the forward slash (which is returned by the AltDirectorySeparatorChar field) or the backslash (which is returned by the DirectorySeparatorChar field) as path separator characters, while Unix-based systems support only the forward slash.

It's also worth noting that each OS has different invalid path chars. I have some 404'ed images because some of my files have leading spaces on Linux but underscores on Windows. More on that )(and other obscure but fun bugs/behaviors) in future posts.

static void Main()
{
    Console.WriteLine($"Path.DirectorySeparatorChar: '{Path.DirectorySeparatorChar}'");
    Console.WriteLine($"Path.AltDirectorySeparatorChar: '{Path.AltDirectorySeparatorChar}'");
    Console.WriteLine($"Path.PathSeparator: '{Path.PathSeparator}'");
    Console.WriteLine($"Path.VolumeSeparatorChar: '{Path.VolumeSeparatorChar}'");
    var invalidChars = Path.GetInvalidPathChars();
    Console.WriteLine($"Path.GetInvalidPathChars:");
    for (int ctr = 0; ctr < invalidChars.Length; ctr++) 
    {
        Console.Write($"  U+{Convert.ToUInt16(invalidChars[ctr]):X4} ");
        if ((ctr + 1) % 10 == 0) Console.WriteLine();
    }
    Console.WriteLine();
}
Here's some articles I've already written on the subject of legacy migrations to the cloud.

Migrating this blog to Azure
Real World Cloud Migrations: Moving a 17 year old series of sites from bare metal to Azure
Dealing with Application Base URLs and Razor link generation while hosting ASP.NET web apps behind Reverse Proxies
Updating an ASP.NET Core 2.2 Web Site to .NET Core 3.1 LTS
Moving an ASP.NET Core from Azure App Service on Windows to Linux by testing in WSL and Docker first
If you find any issues with this blog like

Broken links and 404s where you wouldn't expect them
Broken images, zero byte images, giant images
General oddness
Please file them here https://github.com/shanselman/hanselman.com-bugs and let me know!

Oh, and please subscribe to my YouTube and tell your friends. It's lovely.

Sponsor: Have you tried developing in Rider yet? This fast and feature-rich cross-platform IDE improves your code for .NET, ASP.NET, .NET Core, Xamarin, and Unity applications on Windows, Mac, and Linux.

ABOUT SCOTT
Scott Hanselman is a former professor, former Chief Architect in finance, now speaker, consultant, father, diabetic, and Microsoft employee. He is a failed stand-up comic, a cornrower, and a book author.

facebook twitter subscribe
About   Newsletter
Hosting By
Hosted in an Azure App Service
Comment on this post [0]
Share on Twitter or Facebook or use the Permalink
Classic Path.DirectorySeparatorChar gotchas when moving from .NET Core on Windows to Linux
October 13, 2020 Comment on this post [0] Posted in Azure | DotNetCore | Linux 
Sponsored By
Report Ad
It's a Unix System, I know this!An important step in moving my blog to Azure was to consider getting this .NET app, now a .NET Core app, to run on Linux AND Windows. Being able to run on Linux and Windows would give me and others a wider choice of hosting, allow hosting in Linux Containers, and for me, save me money as Linux Hosting tends to be cheaper, even on Azure.

Getting something to compile on Linux is not the same as getting it to run, of course.

Additionally, something might run well in one context and not other. My partner Mark (poppastring) on this project has been running this code on .NET for a while, albeit on Windows. Additionally he runs on IIS in /blog as a subapplication. I run on Linux on Azure, and while I'm also on /blog, my site is behind Azure Front Door as a reverse proxy which handles the domain/blog/path and forwards along domain/path to the app.

Long story short, it's worked on both his blog and mine, until I tried to post a new blog post.

I use Open Live Writer (open sourced version of Windows Live Writer) to make a MetaWebLog API call to my blog. There's multiple calls to upload the binaries (PNGs) and a path is returned.  A newly uploaded binary might have a path like https://hanselman.com/blog/content/binary/something.png. The file on disk (from the server's perspective) might be d:\whatever\site\wwwroot\content\binary\something.png.

This is 15 year old ASP.NET 1, so there's some idiomatic stuff going on here that isn't modern, plus the vars have been added for watch window debugging, but do you see the potential issue?

private string GetAbsoluteFileUri(string fullPath, out string relFileUri)
{
    var relPath = fullPath.Replace(contentLocation, "").TrimStart('\\'); 
    var relUri = new Uri( relPath, UriKind.Relative);
    relFileUri = relUri.ToString();
    return new Uri(binaryRoot, relPath).ToString();
}
That '\\' is making a big assumption. A reasonable one in 2003, but a big one today. It's trimming a backslash off the start of the passed in string. Then the Uri constructor starts coming things and we're mixing and matching \ and / and we end up with truncated URLs that don't resolve.

Assumptions about path separators are a top issue when moving .NET code to Linux or Mac, and it's often buried deep in utiltiy methods like this.

var relPath = fullPath.Replace(contentLocation, String.Empty).TrimStart(Path.DirectorySeparatorChar);
We can use the correct constant for Path.DirectorySeparatorChar, or the little-known AltDirectorySeparatorChar as Windows supports both. That's why this code works on Mark's Windows deployment but doesn't break until it runs on my Linux deployment.

DOCS: Note that Windows supports either the forward slash (which is returned by the AltDirectorySeparatorChar field) or the backslash (which is returned by the DirectorySeparatorChar field) as path separator characters, while Unix-based systems support only the forward slash.

It's also worth noting that each OS has different invalid path chars. I have some 404'ed images because some of my files have leading spaces on Linux but underscores on Windows. More on that )(and other obscure but fun bugs/behaviors) in future posts.

static void Main()
{
    Console.WriteLine($"Path.DirectorySeparatorChar: '{Path.DirectorySeparatorChar}'");
    Console.WriteLine($"Path.AltDirectorySeparatorChar: '{Path.AltDirectorySeparatorChar}'");
    Console.WriteLine($"Path.PathSeparator: '{Path.PathSeparator}'");
    Console.WriteLine($"Path.VolumeSeparatorChar: '{Path.VolumeSeparatorChar}'");
    var invalidChars = Path.GetInvalidPathChars();
    Console.WriteLine($"Path.GetInvalidPathChars:");
    for (int ctr = 0; ctr < invalidChars.Length; ctr++) 
    {
        Console.Write($"  U+{Convert.ToUInt16(invalidChars[ctr]):X4} ");
        if ((ctr + 1) % 10 == 0) Console.WriteLine();
    }
    Console.WriteLine();
}
Here's some articles I've already written on the subject of legacy migrations to the cloud.

Migrating this blog to Azure
Real World Cloud Migrations: Moving a 17 year old series of sites from bare metal to Azure
Dealing with Application Base URLs and Razor link generation while hosting ASP.NET web apps behind Reverse Proxies
Updating an ASP.NET Core 2.2 Web Site to .NET Core 3.1 LTS
Moving an ASP.NET Core from Azure App Service on Windows to Linux by testing in WSL and Docker first
If you find any issues with this blog like

Broken links and 404s where you wouldn't expect them
Broken images, zero byte images, giant images
General oddness
Please file them here https://github.com/shanselman/hanselman.com-bugs and let me know!

Oh, and please subscribe to my YouTube and tell your friends. It's lovely.

Sponsor: Have you tried developing in Rider yet? This fast and feature-rich cross-platform IDE improves your code for .NET, ASP.NET, .NET Core, Xamarin, and Unity applications on Windows, Mac, and Linux.

ABOUT SCOTT
Scott Hanselman is a former professor, former Chief Architect in finance, now speaker, consultant, father, diabetic, and Microsoft employee. He is a failed stand-up comic, a cornrower, and a book author.

facebook twitter subscribe
About   Newsletter
Hosting By
Hosted in an Azure App Service
Comment on this post [0]
Share on Twitter or Facebook or use the Permalink
Migrating this blog to Azure. It's done. Now the work begins.
October 08, 2020 Comment on this post [0] Posted in ASP.NET | Azure 
Sponsored By
Report Ad
imageI have been running this https://hanselman.com/blog for almost 20 years. Like coming up on 19 I believe.

Recently it moved from being:

a 13(?) year old .NET Framework app called DasBlog running on ASP.NET and a Windows Server on real metal hardware
to

a fresh and new .NET Core app app forked and improved by Mark Downie https://github.com/poppastring/dasblog-core and running under Linux on Azure!
Finally. This blog, the main site, and the podcast site are all running on Azure Web Apps, built in Azure DevOps, and managed by Azure Front Door and watched by Application Insights. Yes I pay for it with cash, I have no unlimited free Azure credits other than my $100 MSDN account.

Mark and I have been pairing on this for months and having a wonderful time. In fact, it's been about a year since this started.

Moving this blog is a significant achievement for a number of reasons, IMHO.

If we did it right:
you didn't notice anything
The URLs look cooler.
We broke nothing in SEO.
Perf is better.
Before I could deploy the site a few times a year, and was afraid of it. Yesterday I deployed 11 times.
It was .NET 1.1, then 2.0, then 3.5, then 4.0, then stuck for 8 years.
It ran on a real Windows Server 2008 machine (no VM) at Sherweb who has been a great partner for years. Extremely reliable hosting!
Now it's on Azure under Linux
We upgraded the ASP.NET WebForms app to ASP.NET Core with Mark's genius idea of splitting the app responsibilities such that the original DasBlog blog templating language could be converted to simple Razor pages and we could use ASP.NET TagHelpers to replace WebForms controls.
This allowed me to port my template over in a day with minimal changes.
Once it compiled under .NET Core it was easy to move it from Windows to Linux and testing in WSL first.
We then just moved the other dependent projects to .NET Standard 2 and compiled the while thing as a .NET Core 3.1 LTS (Long Term Support) app. In fact, scroll down to the VERY bottom of this page and you can see what version we're on.
I set up CI/CD for the main site hanselman.com, this blog, and hanselminutes.com.
There are 3 sites now, all behind a reverse proxy from Azure Front Door to handle SSL, Firewalls, and more.

Next steps? Keep it running, watch for errors, 5xx and 4xx and make small incremental changes. The pages are still heavy, while ASP.NET has server response time under 20ms, there's still 2 sec of JavaScript and bunch of old crap to clean up. I've also got two decades of links, so I'm fixing 404s as they are reported or they show up in Application Insights. I made a Dashboard here:

image
I'm going spend the next month or so blogging about the process and experience in as much detail as I can.

Here's some articles I've already written on the subject:

Real World Cloud Migrations: Moving a 17 year old series of sites from bare metal to Azure
Dealing with Application Base URLs and Razor link generation while hosting ASP.NET web apps behind Reverse Proxies
Updating an ASP.NET Core 2.2 Web Site to .NET Core 3.1 LTS
Moving an ASP.NET Core from Azure App Service on Windows to Linux by testing in WSL and Docker first
If you find any issues with this blog like

Broken links and 404s where you wouldn't expect them
Broken images, zero byte images, giant images
General oddness
Please file them here https://github.com/shanselman/hanselman.com-bugs and let me know!

Oh, and please subscribe to my YouTube and tell your friends. It's lovely.

Sponsor: Never miss a beat with Seq. Live application logs and health checks. Download the Windows installer or pull the Docker image now.

ABOUT SCOTT
Scott Hanselman is a former professor, former Chief Architect in finance, now speaker, consultant, father, diabetic, and Microsoft employee. He is a failed stand-up comic, a cornrower, and a book author.

facebook twitter subscribe
About   Newsletter
Hosting By
Hosted in an Azure App Service
Comment on this post [0]
Share on Twitter or Facebook or use the Permalink
Keeping your WSL Linux instances up to date automatically within Windows 10
October 06, 2020 Comment on this post [0] Posted in Linux | Win10 
Sponsored By


            </p>
        </div>
    </section>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="../dist/talkify.js"></script>

    <script>
        talkify.config.debug = true;
        talkify.config.useSsml = false;
        talkify.config.remoteService.active = true;
        talkify.config.keyboardCommands.enabled = true;
        talkify.config.voiceCommands.enabled = true;

        talkify.config.remoteService.speechBaseUrl = '/api/speech/v2';
        talkify.config.remoteService.languageBaseUrl = '/api/language/v2';

        talkify.config.remoteService.apiKey = '612ee344-d1de-429c-a518-3578458257c5';

        talkify.config.remoteService.host = 'http://localhost:6719';

        talkify.config.ui.audioControls.controlcenter = "local";
        talkify.config.ui.audioControls.enabled = true; //<-- Disable to get the browser built in audio controls
        talkify.config.ui.audioControls.container = document.querySelector(".talkify-control-center-placeholder");
        talkify.config.ui.audioControls.voicepicker = {
            enabled: false
        };

        $(document).ready(function () {
            var player = new talkify.TtsPlayer()
                .enableTextHighlighting();

            player.forceVoice({ name: 'Zira', description: "Zira" });

            var playlist = new talkify.playlist()
                .begin()
                .usingPlayer(player)
                .withRootSelector('.talkify-section')
                .build();
        });

    </script>
</body>

</html>